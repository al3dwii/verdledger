package ledger

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
)

// Queries wraps prepared SQL queries. Generated by sqlc normally.
type Queries struct{ db *pgxpool.Pool }

// New creates a new Queries wrapper.
func New(db *pgxpool.Pool) *Queries { return &Queries{db: db} }

// InsertEventParams contains parameters for InsertEvent.
type InsertEventParams struct {
	OrgID     int64
	ProjectID int64
	Cloud     string
	Region    string
	Sku       string
	Kwh       float64
	Usd       float64
	Kg        float64
	Note      string
}

// ProjectSummaryParams for querying project summaries.
type ProjectSummaryParams struct {
	OrgID     int64
	ProjectID int64
}

type ProjectSummaryRow struct {
	TotalUsd float64 `json:"total_usd"`
	TotalKg  float64 `json:"total_kg"`
}

// CreateProject inserts a new project and returns it.
func (q *Queries) CreateProject(ctx context.Context, orgID int64, name string) (Project, error) {
	row := q.db.QueryRow(ctx, `INSERT INTO public.project (org_id, name) VALUES ($1,$2) RETURNING id, org_id, name, created_at`, orgID, name)
	var p Project
	err := row.Scan(&p.ID, &p.OrgID, &p.Name, &p.CreatedAt)
	return p, err
}

// InsertEvent inserts an event and returns the row.
func (q *Queries) InsertEvent(ctx context.Context, arg InsertEventParams) (SavingsEvent, error) {
	row := q.db.QueryRow(ctx, `INSERT INTO public.savings_event (org_id, project_id, cloud, region, sku, kwh, usd, kg, note) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING id, org_id, ts, cloud, region, sku, kwh, usd, kg, note, project_id`,
		arg.OrgID, arg.ProjectID, arg.Cloud, arg.Region, arg.Sku, arg.Kwh, arg.Usd, arg.Kg, arg.Note)
	var ev SavingsEvent
	var projectID sql.NullInt64
	err := row.Scan(&ev.ID, &ev.OrgID, &ev.Ts, &ev.Cloud, &ev.Region, &ev.Sku, &ev.Kwh, &ev.Usd, &ev.Kg, &ev.Note, &projectID)
	// Attach to struct if needed - existing struct doesn't have ProjectID; but we added column. We'll extend struct accordingly below.
	ev.ProjectID = projectID
	return ev, err
}

// ListEvents lists events for an org with pagination.
func (q *Queries) ListEvents(ctx context.Context, orgID int64, limit, offset int32) ([]SavingsEvent, error) {
	rows, err := q.db.Query(ctx, `SELECT id, org_id, ts, cloud, region, sku, kwh, usd, kg, note, project_id FROM public.savings_event WHERE org_id = $1 ORDER BY ts DESC LIMIT $2 OFFSET $3`, orgID, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SavingsEvent
	for rows.Next() {
		var ev SavingsEvent
		var projectID sql.NullInt64
		if err := rows.Scan(&ev.ID, &ev.OrgID, &ev.Ts, &ev.Cloud, &ev.Region, &ev.Sku, &ev.Kwh, &ev.Usd, &ev.Kg, &ev.Note, &projectID); err != nil {
			return nil, err
		}
		ev.ProjectID = projectID
		items = append(items, ev)
	}
	return items, rows.Err()
}

// OrgSummary returns totals for an org.
func (q *Queries) OrgSummary(ctx context.Context, orgID int64) (ProjectSummaryRow, error) {
	row := q.db.QueryRow(ctx, `SELECT * FROM public.ledger_summary($1, NULL)`, orgID)
	var res ProjectSummaryRow
	err := row.Scan(&res.TotalUsd, &res.TotalKg)
	return res, err
}

// ProjectSummary returns totals for a project.
func (q *Queries) ProjectSummary(ctx context.Context, arg ProjectSummaryParams) (ProjectSummaryRow, error) {
	row := q.db.QueryRow(ctx, `SELECT * FROM public.ledger_summary($1, $2)`, arg.OrgID, arg.ProjectID)
	var res ProjectSummaryRow
	err := row.Scan(&res.TotalUsd, &res.TotalKg)
	return res, err
}

type UpsertSubscriptionParams struct {
	OrgID                int64
	StripeCustomerID     string
	StripeSubscriptionID string
	Status               string
	CurrentPeriodEnd     time.Time
}

func (q *Queries) UpsertSubscription(ctx context.Context, arg UpsertSubscriptionParams) error {
	_, err := q.db.Exec(ctx, `insert into billing.org_subscription (org_id, stripe_customer_id, stripe_subscription_id, status, current_period_end) values ($1,$2,$3,$4,$5) on conflict (org_id) do update set status=$4, current_period_end=$5`,
		arg.OrgID, arg.StripeCustomerID, arg.StripeSubscriptionID, arg.Status, arg.CurrentPeriodEnd)
	return err
}

func (q *Queries) FlagEnabled(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRow(ctx, `select enabled from public.feature_flag where name=$1`, name)
	var enabled bool
	err := row.Scan(&enabled)
	return enabled, err
}
