package ledger

import (
    "context"
    "database/sql"

    "github.com/jackc/pgx/v5/pgxpool"
)

// Queries wraps prepared SQL queries. Generated by sqlc normally.
type Queries struct{ db *pgxpool.Pool }

// New creates a new Queries wrapper.
func New(db *pgxpool.Pool) *Queries { return &Queries{db: db} }

// InsertEventParams contains parameters for InsertEvent.
type InsertEventParams struct {
    OrgID     int64
    ProjectID int64
    Cloud     string
    Region    string
    Sku       string
    Kwh       float64
    Usd       float64
    Kg        float64
    Note      string
}

// ProjectSummaryParams for querying project summaries.
type ProjectSummaryParams struct {
    OrgID     int64
    ProjectID int64
}

type ProjectSummaryRow struct {
    TotalUsd float64 `json:"total_usd"`
    TotalKg  float64 `json:"total_kg"`
}

// CreateProject inserts a new project and returns it.
func (q *Queries) CreateProject(ctx context.Context, orgID int64, name string) (Project, error) {
    row := q.db.QueryRow(ctx, `INSERT INTO public.project (org_id, name) VALUES ($1,$2) RETURNING id, org_id, name, created_at`, orgID, name)
    var p Project
    err := row.Scan(&p.ID, &p.OrgID, &p.Name, &p.CreatedAt)
    return p, err
}

// InsertEvent inserts an event and returns the row.
func (q *Queries) InsertEvent(ctx context.Context, arg InsertEventParams) (SavingsEvent, error) {
    row := q.db.QueryRow(ctx, `INSERT INTO public.savings_event (org_id, project_id, cloud, region, sku, kwh, usd, kg, note) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING id, org_id, ts, cloud, region, sku, kwh, usd, kg, note, project_id`,
        arg.OrgID, arg.ProjectID, arg.Cloud, arg.Region, arg.Sku, arg.Kwh, arg.Usd, arg.Kg, arg.Note)
    var ev SavingsEvent
    var projectID sql.NullInt64
    err := row.Scan(&ev.ID, &ev.OrgID, &ev.Ts, &ev.Cloud, &ev.Region, &ev.Sku, &ev.Kwh, &ev.Usd, &ev.Kg, &ev.Note, &projectID)
    // Attach to struct if needed - existing struct doesn't have ProjectID; but we added column. We'll extend struct accordingly below.
    ev.ProjectID = projectID
    return ev, err
}

// ListEvents lists events for an org with pagination.
func (q *Queries) ListEvents(ctx context.Context, orgID int64, limit, offset int32) ([]SavingsEvent, error) {
    rows, err := q.db.Query(ctx, `SELECT id, org_id, ts, cloud, region, sku, kwh, usd, kg, note, project_id FROM public.savings_event WHERE org_id = $1 ORDER BY ts DESC LIMIT $2 OFFSET $3`, orgID, limit, offset)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    var items []SavingsEvent
    for rows.Next() {
        var ev SavingsEvent
        var projectID sql.NullInt64
        if err := rows.Scan(&ev.ID, &ev.OrgID, &ev.Ts, &ev.Cloud, &ev.Region, &ev.Sku, &ev.Kwh, &ev.Usd, &ev.Kg, &ev.Note, &projectID); err != nil {
            return nil, err
        }
        ev.ProjectID = projectID
        items = append(items, ev)
    }
    return items, rows.Err()
}

// OrgSummary returns totals for an org.
func (q *Queries) OrgSummary(ctx context.Context, orgID int64) (ProjectSummaryRow, error) {
    row := q.db.QueryRow(ctx, `SELECT * FROM public.ledger_summary($1, NULL)`, orgID)
    var res ProjectSummaryRow
    err := row.Scan(&res.TotalUsd, &res.TotalKg)
    return res, err
}

// ProjectSummary returns totals for a project.
func (q *Queries) ProjectSummary(ctx context.Context, arg ProjectSummaryParams) (ProjectSummaryRow, error) {
    row := q.db.QueryRow(ctx, `SELECT * FROM public.ledger_summary($1, $2)`, arg.OrgID, arg.ProjectID)
    var res ProjectSummaryRow
    err := row.Scan(&res.TotalUsd, &res.TotalKg)
    return res, err
}
